# Structurelint configuration for Python Refactor MCP
# Comprehensive project structure and quality enforcement

root: true

exclude:
  # Version control
  - .git/**

  # Python artifacts
  - __pycache__/**
  - .pytest_cache/**
  - "*.pyc"
  - "*.pyo"
  - "*.egg-info"

  # Virtual environments
  - venv/**
  - .venv/**
  - env/**

  # Build artifacts
  - dist/**
  - build/**

  # IDE
  - .vscode/**
  - .idea/**

rules:
  # ============================================================================
  # Phase 0: Basic Filesystem Rules
  # ============================================================================

  max-depth:
    max: 5

  max-files-in-dir:
    max: 20

  max-subdirs:
    max: 10

  # Python naming conventions - snake_case for everything
  naming-convention:
    "**/*.py": "snake_case"
    "**/": "snake_case"

  # Documentation requirements - every directory should have a README
  file-existence:
    "README.md": "exists:1"

  # Disallow temporary and problematic files
  disallowed-patterns:
    - "*.tmp"
    - "*.bak"
    - ".DS_Store"
    - "Thumbs.db"
    - "**/*.swp"
    - "**/__pycache__"
    - "**/*.pyc"
    - "**/*.pyo"
    - "**/.pytest_cache"

  # ============================================================================
  # Phase 1: Architectural Layer Enforcement
  # ============================================================================

  enforce-layer-boundaries: true

  # ============================================================================
  # Phase 2: Dead Code Detection
  # ============================================================================

  # Ensure all Python files are reachable from entry points
  # Disabled for now - Python import detection needs improvement
  # disallow-orphaned-files: true

  # Detect unused exports (functions/classes that are never imported)
  # Disabled for now - Python export detection needs improvement
  # disallow-unused-exports: true

  # ============================================================================
  # Phase 3: Test File Validation
  # ============================================================================

  # All Python modules should have corresponding test files
  test-adjacency:
    pattern: "separate"
    test-dir: "tests"
    file-patterns:
      - "src/**/*.py"
      - "tests/**/*.py"
    exemptions:
      - "**/__init__.py"      # Package initializers don't need tests

  test-location:
    integration-test-dir: "tests"
    allow-adjacent: false
    file-patterns:
      - "**/*_test.py"
      - "**/test_*.py"
    exemptions:
      - "testdata/**"
      - "example_project/**"

  # ============================================================================
  # Evidence-Based Complexity Metrics
  # ============================================================================

  # Cognitive Complexity - measures how hard code is to understand
  # Research shows r=0.54 correlation with comprehension time
  # Penalizes nesting, control flow complexity
  max-cognitive-complexity:
    max: 40      # Pragmatic threshold for existing codebase
                 # Target: Reduce to 15 over time (industry best practice)
                 # Current violations:
                 # - _read_responses: 39 (needs refactoring)
                 # - call_tool: 18 (needs refactoring)
                 # - _apply_single_edit: 19 (needs refactoring)
    file-patterns:
      - "src/**/*.py"
    exemptions:
      - "**/__init__.py"

  # Halstead Effort - captures data complexity
  # Research shows rs=0.901 correlation with cognitive load
  # Tracks operators, operands, vocabulary size
  max-halstead-effort:
    max: 100000   # Appropriate for Python (lower than TypeScript due to less syntax)
    file-patterns:
      - "src/**/*.py"
    exemptions:
      - "**/__init__.py"
      - "tests/**"

  # ============================================================================
  # Linter Configuration Enforcement
  # ============================================================================

  # Ensure Python linters are configured (black, ruff, mypy, etc.)
  # Accepts either config files OR GitHub workflow running linters
  linter-config:
    require-python: true

  # ============================================================================
  # Phase 8: GitHub Workflow Enforcement
  # ============================================================================

  # Ensure CI/CD pipelines are properly configured
  # Note: Currently disabled due to detection issues with .github/workflows
  # Re-enable once structurelint Python support improves
  # github-workflows:
  #   require-tests: true
  #   require-quality: true

# ============================================================================
# Overrides for Specific Directories
# ============================================================================

overrides:
  # Source code in src/ - stricter rules
  - files: ['src/**']
    rules:
      max-depth: { max: 4 }
      max-files-in-dir: { max: 15 }
      # Stricter complexity for production code
      max-cognitive-complexity: { max: 12 }
      max-halstead-effort: { max: 80000 }

  # Tests can be more flexible
  - files: ['tests/**']
    rules:
      max-depth: { max: 5 }
      max-files-in-dir: { max: 25 }
      # Tests don't need to avoid dead code (fixtures, helpers)
      disallow-orphaned-files: 0
      disallow-unused-exports: 0
      # Integration tests can be complex
      max-cognitive-complexity: 0
      max-halstead-effort: 0

  # Root level can have more files (configs, docs, etc.)
  - files: ['.']
    rules:
      max-files-in-dir: { max: 30 }
      # Root level files are often entry points or configs
      disallow-orphaned-files: 0

  # Config files and documentation don't need to be imported
  - files: ['*.json', '*.yaml', '*.yml', '*.toml', '*.md', '*.txt', 'LICENSE', '.pre-commit-config.yaml']
    rules:
      disallow-orphaned-files: 0
      disallow-unused-exports: 0

  # Package exports are for external consumption
  - files: ['src/**/__init__.py']
    rules:
      disallow-unused-exports: 0

  # Example project is for testing
  - files: ['tests/example_project/**']
    rules:
      disallow-unused-exports: 0

# ============================================================================
# Phase 1: Architectural Layers
# ============================================================================

layers:
  - name: mcp_server
    path: src/python_refactor_mcp/**
    dependsOn: []

# ============================================================================
# Phase 2: Dead Code Detection - Entry Points
# ============================================================================

entrypoints:
  - src/python_refactor_mcp/__main__.py
  - "tests/**/*.py"

# ============================================================================
# Configuration Philosophy
# ============================================================================
#
# This configuration implements evidence-based software quality metrics:
#
# 1. Cognitive Complexity (CoC):
#    - Validated metric for code comprehension
#    - Threshold of 15 based on empirical research
#    - Stricter (12) for production code in src/
#
# 2. Halstead Effort:
#    - Measures data/operator complexity
#    - Complements CoC by catching different complexity patterns
#    - 100K threshold appropriate for Python
#
# 3. Architectural Enforcement:
#    - Layer boundaries prevent circular dependencies
#    - Dead code detection ensures all code is reachable
#    - Unused export detection finds orphaned functions
#
# 4. Test Validation:
#    - Every source file requires corresponding test
#    - Tests mirror source directory structure
#    - Integration tests in separate directory
#
# 5. CI/CD Validation:
#    - Ensures tests run automatically
#    - Validates linter configuration exists
#    - Enforces quality gates in GitHub Actions
#
# Benefits:
# - Prevents technical debt accumulation
# - Enforces maintainability from day one
# - Provides objective quality metrics
# - Catches architectural violations early
# - Ensures comprehensive testing
#
